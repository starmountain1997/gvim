" =============================================================================
" === 基本设置 ===
" =============================================================================

" 关闭与 Vi 的兼容模式，使用 Vim 的全部功能
set nocompatible
" 设置文件编码为 UTF-8
set encoding=utf-8
" 启用鼠标支持
set mouse=a
" 当文件在外部被修改时自动重新加载
set autoread
" 使用 j/k 移动时，光标不回到行首
set nostartofline


" =============================================================================
" === 插件列表 (vim-plug) ===
" =============================================================================

call plug#begin()

" --- 主题与外观 ---
Plug 'dracula/vim', { 'as': 'dracula' }
Plug 'vim-airline/vim-airline'

" --- 文件浏览与管理 ---
Plug 'preservim/nerdtree'
Plug 'ryanoasis/vim-devicons'
Plug 'tiagofumo/vim-nerdtree-syntax-highlight'



" --- 语法与高亮 ---
Plug 'luochen1990/rainbow'
Plug 'dominikduda/vim_current_word'

" --- 上下文显示 (滚动时冻结函数声明) ---
Plug 'wellle/context.vim'

" --- 编辑辅助 ---
Plug 'tpope/vim-commentary'
Plug 'jiangmiao/auto-pairs'
Plug 'mhinz/vim-signify', { 'tag': 'legacy'  }

" --- 系统剪贴板支持 ---
Plug 'ojroques/vim-oscyank'

" --- 会话管理 ---
Plug 'tpope/vim-obsession'


" --- 代码检查与修复 ---
Plug 'prabirshrestha/vim-lsp'
Plug 'mattn/vim-lsp-settings'
Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/asyncomplete-lsp.vim'

" --- 代码调试 ---
Plug 'puremourning/vimspector'



call plug#end()

" =============================================================================
" === 主题配置 ===
" =============================================================================

" 启用 Dracula 主题
syntax enable
" 确保终端支持足够的颜色
if !has('gui_running') && &t_Co < 256
    set t_Co=256
endif
" 尝试加载 Dracula 主题，如果失败则使用默认主题
try
    colorscheme dracula
catch /^Vim\%((\a\+)\)\=:E185/
    colorscheme default
    echo "Dracula theme not found, using default theme"
endtry

" =============================================================================
" === 外观与 UI ===
" =============================================================================

" --- 颜色与主题 ---
" 启用终端的真彩色支持
if has('termguicolors')
    set termguicolors
else
    " 如果不支持真彩色，使用256色模式
    set t_Co=256
endif
" 与终端一致的透明配置
hi! Normal guibg=NONE ctermbg=NONE


" --- 界面元素 ---
" 显示行号
set number
" 显示相对行号，便于跳转
set relativenumber
" 高亮显示当前行
set cursorline
" 高亮显示当前列
set cursorcolumn
" 在状态栏显示光标位置
set ruler

" --- 终端光标形状 ---
" 在特定终端中，根据模式设置光标形状
if &term =~# '\v(xterm|rxvt|alacritty|kitty)'
    let &t_EI = "\<Esc>[2 q" " 普通模式光标 (block)
    let &t_SI = "\<Esc>[6 q" " 插入模式光标 (line)
    let &t_SR = "\<Esc>[4 q" " 替换模式光标 (underline)
endif


" =============================================================================
" === 编辑与文本行为 ===
" =============================================================================

" --- 缩进与制表符 ---
" 设置制表符宽度为 4 个空格
set tabstop=4
" 设置自动缩进的宽度为 4 个空格
set shiftwidth=4
" 将制表符转换为空格
set expandtab
" 新行自动缩进
set autoindent

" --- 换行 ---
" 默认不自动换行
set nowrap

" --- 搜索 ---
" 搜索时高亮显示匹配项
set hlsearch
" 输入搜索内容时即时高亮
set incsearch
" 搜索时忽略大小写
set ignorecase
" 如果搜索内容包含大写字母，则不忽略大小写（智能大小写）
set smartcase




" =============================================================================
" === 文件与自动命令 ===
" =============================================================================

" 开启文件类型检测、插件和缩进
filetype plugin indent on

" 当 vimrc 文件被保存后，自动重新加载配置
autocmd BufWritePost *vimrc so $MYVIMRC

" 针对特定文件类型（markdown, text）开启自动换行
if has("autocmd")
    augroup filetype_settings
        autocmd!
        " 当 Vim 识别文件类型为 markdown 或 text 时，执行后续命令
        autocmd FileType markdown,text setlocal wrap
    augroup END
endif




" =============================================================================
" === 插件配置 ===
" =============================================================================

" --- NERDTree ---
" 映射 F1 键来开关 NERDTree (使用nnoremap避免递归映射)
nnoremap <F1> :NERDTreeToggle<CR>
" 书签相关快捷键
nnoremap <leader>bb :Bookmark<space>
nnoremap <leader>bc :ClearAllBookmarks<CR>
nnoremap <leader>be :EditBookmarks<CR>
" 当 NERDTree 是最后一个窗口时，自动退出 Vim
autocmd BufEnter * if tabpagenr('$') == 1 && winnr('$') == 1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | call feedkeys(":quit\<CR>:\<BS>") | endif
" 设置 NERDTree 忽略的文件和文件夹
let g:NERDTreeIgnore = ['__pycache__',  '.ruff_cache',  '.git', '.*\.egg-info$', '.claude', '.DS_Store', 'Session.vim', '*.swp', '.*\.swp$', '.*\.swo$', '.*\.swn$', 'uv.lock', 'pytest.ini', '.pytest_cache', '.idea']
" 显示隐藏文件
let g:NERDTreeShowHidden = 1

" --- NERDTree 自动刷新功能配置 ---
" 当切换回Vim时自动刷新NERDTree
autocmd FocusGained * if exists(':NERDTree') | NERDTreeRefresh | endif
" 当文件改变时自动刷新NERDTree
autocmd BufWritePost * if exists(':NERDTree') | NERDTreeRefresh | endif
" 当Vim失去焦点后再获得焦点时刷新NERDTree
autocmd BufEnter * if exists('t:NERDTreeBufName') && winbufnr(2) != -1 | NERDTreeRefresh | endif

" --- vim-airline ---
" 启用 powerline 字体，使状态栏显示特殊符号
let g:airline_powerline_fonts = 1

" --- rainbow (彩虹括号) ---
" 启用 rainbow 插件
let g:rainbow_active = 1


" --- vim_current_word ---
" 高亮与当前光标下单词相同的所有单词
let g:vim_current_word#highlight_twins = 1
" 高亮当前光标下的单词
let g:vim_current_word#highlight_current_word = 1
" 高亮延迟设为 0，立即高亮
let g:vim_current_word#highlight_delay = 0


" --- context.vim (上下文显示) ---
" 启用 context.vim 插件
let g:context_enabled = 1
" 设置上下文显示的最大行数
let g:context_max_lines = 10
" 设置上下文显示的最小行数
let g:context_min_lines = 1
" 在文件类型中启用 context.vim (支持多种编程语言)
let g:context_filetype_blacklist = []



" --- 全局 LSP 快捷键映射 ---
" 这些快捷键会在 LSP 可用时自动生效
nnoremap gd <plug>(lsp-definition)
nnoremap gs <plug>(lsp-document-symbol-search)
nnoremap gS <plug>(lsp-workspace-symbol-search)
nnoremap gr <plug>(lsp-references)
nnoremap gi <plug>(lsp-implementation)
nnoremap gt <plug>(lsp-type-definition)
nnoremap <leader>rn <plug>(lsp-rename)
nnoremap [g <plug>(lsp-previous-diagnostic)
nnoremap ]g <plug>(lsp-next-diagnostic)
nnoremap K <plug>(lsp-hover)

" --- LSP 诊断显示配置 ---
" 启用 LSP 诊断系统
let g:lsp_diagnostics_enabled = 1
" 在光标移动时，在命令行显示当前行的诊断信息
let g:lsp_diagnostics_echo_cursor = 1
" 禁用行内虚拟文本显示（避免代码中的干扰性文本）
let g:lsp_diagnostics_virtual_text_enabled = 0


" --- 补全设置 ---
" allow modifying the completeopt variable, or it will
" be overridden all the time
let g:asyncomplete_auto_completeopt = 0

" 设置补全选项：menuone(总是显示菜单)，noinsert(不自动插入文本)
" preview(显示预览)，移除 noselect 以允许自动选择第一个
set completeopt=menuone,noinsert,preview

" 补全快捷键配置 (Tab 键保持原生功能，使用上下键选择补全选项)
" 如果补全菜单可见，使用 Enter 键确认当前高亮选项，否则插入一个换行符
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<CR>"

" 补全完成后关闭预览窗口
autocmd! CompleteDone * if pumvisible() == 0 | pclose | endif


" --- vim-oscyank (系统剪贴板支持) ---
" 设置无限制长度，允许复制大量文本
let g:oscyank_max_length = 0
" 禁用成功复制的消息
let g:oscyank_silent = 1

" 在剪贴板不可用的情况下自动复制到系统剪贴板
if (!has('nvim') && !has('clipboard_working'))
    " 检查这些寄存器：无名寄存器("")、选择寄存器("+")、剪贴板寄存器("*")
    let s:VimOSCYankPostRegisters = ['', '+', '*']
    " 在复制(y)和删除(d)操作时都触发
    let s:VimOSCYankOperators = ['y', 'd']
    function! s:VimOSCYankPostCallback(event)
        if index(s:VimOSCYankPostRegisters, a:event.regname) != -1
            \ && index(s:VimOSCYankOperators, a:event.operator) != -1
            call OSCYankRegister(a:event.regname == '' ? '"' : a:event.regname)
        endif
    endfunction
    augroup VimOSCYankPost
        autocmd!
        autocmd TextYankPost * call s:VimOSCYankPostCallback(v:event)
    augroup END
endif


" --- vim-obsession (会话管理) ---
" 自动保存会话，重启 vim 时自动恢复工作状态
" 如果存在 Session.vim 文件且未通过 -S 参数加载，启动时自动加载会话
" 避免与 vim -S Session.vim 命令重复加载导致配置冲突
if filereadable(getcwd() . '/Session.vim') && !v:this_session
    source Session.vim
endif

" --- viminspector ---
let g:vimspector_enable_mappings = 'HUMAN'

" --- 终端窗口自动清理配置 ---
" 确保在退出或关闭缓冲区时正确处理终端窗口，避免终端进程悬停
augroup TermCloseOnQuit
  autocmd!
  " 当终端缓冲区被删除时，确保进程被正确终止
  autocmd BufWinLeave term://* if &buftype == 'terminal' | call s:kill_terminal() | endif
  " 当Vim退出时，确保所有终端进程被正确清理
  autocmd VimLeavePre * call s:cleanup_terminals()
augroup END

" 终止当前终端进程
function! s:kill_terminal()
  if exists('b:terminal_job_id')
    silent! call jobstop(b:terminal_job_id)
  endif
endfunction

" 安全清理终端函数：只清理终端缓冲区，不影响其他文件
function! s:cleanup_terminals()
  for buf in getbufinfo()
    if buf.name =~# '^term://'
      " 终止终端进程
      if getbufvar(buf.bufnr, 'terminal_job_id', 0) != 0
        silent! call jobstop(getbufvar(buf.bufnr, 'terminal_job_id'))
      endif
      " 删除缓冲区
      silent! execute 'bdelete!' buf.bufnr
    endif
  endfor
endfunction
